


## Chapter 1: Introduction

A *view* is ...

---



## Chapter 2: Events

An *event* is a well-defined signal passed into the view by the host system. Events are always generated by the host system. For example, a window hosting a view will create a `resize` event and pass it to the model when it is resized.

#### 2.1 List of events

The following is an exhaustive list of all view events.

- [resize](#221-resize)
- [mousemove](#231-mousemove)
- [mousedown](#232-mouseenter)
- [mousedown](#233-mouseleave)
- [mousedown](#234-mousedown)
- [mouseup](#235-mouseup)
- [click](#236-click)
- [dblclick](#237-dblclick)
- [auxclick](#238-auxclick)
- [wheelup](#239-wheelup)
- [wheeldown](#2310-wheeldown)

#### 2.2 Viewport events

##### 2.2.1 `resize`

#### 2.3 Mouse events

##### 2.3.1 `mousemove`
##### 2.3.2 `mouseenter`
##### 2.3.3 `mouseleave`
##### 2.3.4 `mousedown`
##### 2.3.5 `mouseup`
##### 2.3.6 `click`
##### 2.3.7 `dblclick`
##### 2.3.8 `auxclick`
##### 2.3.9 `wheelup`
##### 2.3.10 `wheeldown`

---



## Chapter 3: Processing

*This chapter covers the technical details of how Bog processes views.*

### 3.1: Building the model

A view's *model* is its concrete, in-memory representation. As such, it must be pre-processed due to technical limitations with querying and manipulating a raw element tree. This pre-processing step is called "building the model".

The process of building a view model involves "digesting" a tree of element representations into more managable mappings of layout nodes to resources like styles and event handlers. Tree digestion is essentially a way of converting user-defined trees of elements with styling and event handlers into usable types for more low-level computations.

The digestion process for each element is as follows:

1. Separate the element's style into two parts: the layout-defining properties (width, font family, etc.) and the non-layout-defining properties (color, border radius, etc.). When event handlers change style properties, we need to know when to re-compute the layout. For example, if an event handler only changes the element's background color, re-computing the layout would be a waste of resources.
2. Use the layout-defining properties and element's tree position (ancestors, descendents, etc.) to create layout nodes that will be used to identify the now-broken element. Remember, elements are only used to build concrete representations of themselves, so the model needs identifiers for the discrete components that define the abstract elements that will no longer be represented in memory as a single "thing".
3. Place the element's components into their respective mappings. Event handlers go into the object map, styles go into the style map, and layouts are now already stored in the layout map. At this point, the "element" no longer exists and its builder is dropped.

---



## Appendix A: Definitions
