


## Chapter 1: Introduction

A *view* is ...

---



## Chapter 2: Events

An *event* is a well-defined signal that corresponds to some occurrence. Events can be classified into one of two categories: *raw* events and *true* events (sometimes just "events"). Raw events include uninterpreted user input (mouse movement, keyboard input, etc.) and system-related occurrences (viewport resizes, loading resources, etc.). True events are generated by the view itself in response to changes in state incurred by these raw events (drag-and-drop, mouse enter/leave, etc.) and as wrappers for raw events. These wrapper-style true events correspond directly with all possible raw events.

Raw events are always generated by the host system and passed into the view's current model. For example, a window hosting a view will create a `resize` event and pass it to the model when it is resized.

#### 2.1 List of events

The following is an exhaustive list of all view events.

- [auxclick](#238-auxclick)
- [click](#236-click)
- [dblclick](#237-dblclick)
- [dragdrop](#2313-dragdrop)
- [dragmove](#2311-dragmove)
- [dragstart](#2312-dragstart)
- [mousedown](#234-mousedown)
- [mouseenter](#232-mouseenter)
- [mouseleave](#233-mouseleave)
- [mousemove](#231-mousemove)
- [mouseup](#235-mouseup)
- [resize](#221-resize)
- [wheelup](#239-wheelup)
- [wheeldown](#2310-wheeldown)

#### 2.2 Viewport events

##### 2.2.1 `resize`

**Generation:** Passed by the host when the viewport changes size.

#### 2.3 Mouse events

##### 2.3.1 `mousemove`

**Generation:** Passed by the host when the user's mouse pointer changes position while over the viewport.

##### 2.3.2 `mouseenter`

**Generation:** When the user's mouse pointer enters the [hitbox](#hitbox) of a [node](#node).

##### 2.3.3 `mouseleave`

**Generation:** When the user's mouse pointer leaves the [hitbox](#hitbox) of a previously entered [node](#node).

##### 2.3.4 `mousedown`

**Generation:** Passed by the host when the user's primary mouse button is pressed while the pointer is over the viewport.

##### 2.3.5 `mouseup`

**Generation:** Passed by the host when the user's primary mouse button releases while the pointer is over the viewport.

##### 2.3.6 `click`

**Generation:** When the user presses and releases the [primary mouse button](#primary-mouse-button) without moving the mouse pointer in such a way that would otherwise indicate a `drag` event.

##### 2.3.7 `dblclick`

**Generation:** When the user presses and releases the primary mouse button twice within the `DOUBLE_CLICK_TIME_FRAME` (by default, 500 milliseconds).

##### 2.3.8 `auxclick`

**Generation:** When the user presses and releases the [secondary mouse button](#secondary-mouse-button) without moving the mouse pointer in such a way that would otherwise indicate a `drag` event.

##### 2.3.9 `wheelup`

**Generation:** Passed by the host when the user's mouse wheel moves upward a single step while the pointer is over the viewport.

##### 2.3.10 `wheeldown`

**Generation:** Passed by the host when the user's mouse wheel moves downward a single step while the pointer is over the viewport.

##### 2.3.11 `dragmove`
##### 2.3.12 `dragstart`
##### 2.3.13 `dragdrop`

---



## Chapter 3: Processing

*This chapter covers the technical details of how Bog processes views.*

### 3.1: Building the model

A view's *model* is its concrete, in-memory representation. As such, it must be pre-processed due to technical limitations with querying and manipulating a raw element tree. This pre-processing step is called "building the model".

The process of building a view model involves "digesting" a tree of element representations into more managable mappings of layout nodes to resources like styles and event handlers. Tree digestion is essentially a way of converting user-defined trees of elements with styling and event handlers into usable types for more low-level computations.

The digestion process for each element is as follows:

1. Separate the element's style into two parts: the layout-defining properties (width, font family, etc.) and the non-layout-defining properties (color, border radius, etc.). When event handlers change style properties, we need to know when to re-compute the layout. For example, if an event handler only changes the element's background color, re-computing the layout would be a waste of resources.
2. Use the layout-defining properties and element's tree position (ancestors, descendents, etc.) to create layout nodes that will be used to identify the now-broken element. Remember, elements are only used to build concrete representations of themselves, so the model needs identifiers for the discrete components that define the abstract elements that will no longer be represented in memory as a single "thing".
3. Place the element's components into their respective mappings. Event handlers go into the object map, styles go into the style map, and layouts are now already stored in the layout map. At this point, the "element" no longer exists and its builder is dropped.

---



## Appendix A: Definitions

### element
### event
### hitbox
### model
### node
### placement
### primary mouse button
### property
### secondary mouse button
### view
